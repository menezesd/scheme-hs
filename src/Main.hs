module Main where

import Types
import Parser (readExprList)
import Env
import Eval
import Primitives (primitiveBindings)
import Control.Monad (unless)
import Control.Monad.Except
import System.Environment (getArgs)
import System.IO

main :: IO ()
main = do
    args <- getArgs
    case args of
        []         -> runRepl
        [filename] -> runFile filename
        _          -> putStrLn "Usage: scheme-hs [filename]"

-- | Standard library definitions
stdlib :: String
stdlib = unlines
    [ ";; Deep car/cdr accessors (R5RS)"
    , "(define (caar x) (car (car x)))"
    , "(define (cadr x) (car (cdr x)))"
    , "(define (cdar x) (cdr (car x)))"
    , "(define (cddr x) (cdr (cdr x)))"
    , "(define (caaar x) (car (car (car x))))"
    , "(define (caadr x) (car (car (cdr x))))"
    , "(define (cadar x) (car (cdr (car x))))"
    , "(define (caddr x) (car (cdr (cdr x))))"
    , "(define (cdaar x) (cdr (car (car x))))"
    , "(define (cdadr x) (cdr (car (cdr x))))"
    , "(define (cddar x) (cdr (cdr (car x))))"
    , "(define (cdddr x) (cdr (cdr (cdr x))))"
    , ";; Four-level deep accessors"
    , "(define (caaaar x) (car (car (car (car x)))))"
    , "(define (caaadr x) (car (car (car (cdr x)))))"
    , "(define (caadar x) (car (car (cdr (car x)))))"
    , "(define (caaddr x) (car (car (cdr (cdr x)))))"
    , "(define (cadaar x) (car (cdr (car (car x)))))"
    , "(define (cadadr x) (car (cdr (car (cdr x)))))"
    , "(define (caddar x) (car (cdr (cdr (car x)))))"
    , "(define (cadddr x) (car (cdr (cdr (cdr x)))))"
    , "(define (cdaaar x) (cdr (car (car (car x)))))"
    , "(define (cdaadr x) (cdr (car (car (cdr x)))))"
    , "(define (cdadar x) (cdr (car (cdr (car x)))))"
    , "(define (cdaddr x) (cdr (car (cdr (cdr x)))))"
    , "(define (cddaar x) (cdr (cdr (car (car x)))))"
    , "(define (cddadr x) (cdr (cdr (car (cdr x)))))"
    , "(define (cdddar x) (cdr (cdr (cdr (car x)))))"
    , "(define (cddddr x) (cdr (cdr (cdr (cdr x)))))"
    , ""
    , "(define (list? x)"
    , "  (or (null? x)"
    , "      (and (pair? x) (list? (cdr x)))))"
    , ""
    , "(define (force promise) (promise))"
    , ""
    , "(define (newline) (display \"\\n\"))"
    , ""
    , "(define (call-with-values producer consumer)"
    , "  (apply consumer (producer)))"
    , ""
    , "(define (values . args) args)"
    , ""
    , "(define (fold-left f init lst)"
    , "  (if (null? lst)"
    , "      init"
    , "      (fold-left f (f init (car lst)) (cdr lst))))"
    , ""
    , "(define (fold-right f init lst)"
    , "  (if (null? lst)"
    , "      init"
    , "      (f (car lst) (fold-right f init (cdr lst)))))"
    , ""
    , "(define foldl fold-left)"
    , "(define foldr fold-right)"
    , ""
    , "(define (filter pred lst)"
    , "  (cond ((null? lst) '())"
    , "        ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))"
    , "        (else (filter pred (cdr lst)))))"
    , ""
    , "(define (any pred lst)"
    , "  (cond ((null? lst) #f)"
    , "        ((pred (car lst)) #t)"
    , "        (else (any pred (cdr lst)))))"
    , ""
    , "(define (all pred lst)"
    , "  (cond ((null? lst) #t)"
    , "        ((not (pred (car lst))) #f)"
    , "        (else (all pred (cdr lst)))))"
    , ""
    , "(define (compose f g)"
    , "  (lambda (x) (f (g x))))"
    , ""
    , ";; curry - note: simplified, only works with single additional arg"
    , "(define (curry f x)"
    , "  (lambda (y) (f x y)))"
    , ""
    , "(define (flip f)"
    , "  (lambda (x y) (f y x)))"
    , ""
    , "(define (id x) x)"
    , ""
    , "(define (const x)"
    , "  (lambda (_) x))"
    , ""
    , "(define (take n lst)"
    , "  (if (or (zero? n) (null? lst))"
    , "      '()"
    , "      (cons (car lst) (take (- n 1) (cdr lst)))))"
    , ""
    , "(define (drop n lst)"
    , "  (if (or (zero? n) (null? lst))"
    , "      lst"
    , "      (drop (- n 1) (cdr lst))))"
    , ""
    , "(define (last lst)"
    , "  (if (null? (cdr lst))"
    , "      (car lst)"
    , "      (last (cdr lst))))"
    , ""
    , "(define (init lst)"
    , "  (if (null? (cdr lst))"
    , "      '()"
    , "      (cons (car lst) (init (cdr lst)))))"
    , ""
    , "(define (zip lst1 lst2)"
    , "  (if (or (null? lst1) (null? lst2))"
    , "      '()"
    , "      (cons (list (car lst1) (car lst2))"
    , "            (zip (cdr lst1) (cdr lst2)))))"
    , ""
    , "(define (unzip lst)"
    , "  (list (map car lst) (map cadr lst)))"
    , ""
    , "(define (range start end)"
    , "  (if (>= start end)"
    , "      '()"
    , "      (cons start (range (+ start 1) end))))"
    , ""
    , "(define (iota n)"
    , "  (range 0 n))"
    , ""
    , "(define (sum lst)"
    , "  (fold-left + 0 lst))"
    , ""
    , "(define (product lst)"
    , "  (fold-left * 1 lst))"
    , ""
    , ";; Dynamic-wind (R5RS) - simplified version"
    , ";; Note: Full dynamic-wind with call/cc integration requires primitive support"
    , "(define (dynamic-wind before body after)"
    , "  (before)"
    , "  (let ((result (body)))"
    , "    (after)"
    , "    result))"
    , ""
    , ";; Promise (delay/force)"
    , "(define (make-promise proc)"
    , "  (let ((result-ready? #f)"
    , "        (result #f))"
    , "    (lambda ()"
    , "      (if result-ready?"
    , "          result"
    , "          (let ((x (proc)))"
    , "            (if result-ready?"
    , "                result"
    , "                (begin (set! result-ready? #t)"
    , "                       (set! result x)"
    , "                       result)))))))"
    , ""
    , ";; force - unwrap a promise"
    , "(define (force promise) (promise))"
    , ""
    , ";; ============================================"
    , ";; SRFI-1: List Library"
    , ";; ============================================"
    , ""
    , ";; Constructors"
    , "(define (xcons d a) (cons a d))"
    , "(define (cons* . args)"
    , "  (if (null? (cdr args))"
    , "      (car args)"
    , "      (cons (car args) (apply cons* (cdr args)))))"
    , "(define (make-list n . fill)"
    , "  (let ((val (if (null? fill) #f (car fill))))"
    , "    (let loop ((n n) (acc '()))"
    , "      (if (<= n 0) acc (loop (- n 1) (cons val acc))))))"
    , "(define (list-tabulate n init-proc)"
    , "  (let loop ((i (- n 1)) (acc '()))"
    , "    (if (< i 0) acc (loop (- i 1) (cons (init-proc i) acc)))))"
    , "(define (list-copy lst) (map id lst))"
    , "(define (circular-list . args)"
    , "  (let ((lst (apply list args)))"
    , "    (set-cdr! (last-pair lst) lst)"
    , "    lst))"
    , "(define (iota count . args)"
    , "  (let ((start (if (null? args) 0 (car args)))"
    , "        (step (if (or (null? args) (null? (cdr args))) 1 (cadr args))))"
    , "    (let loop ((i 0) (acc '()))"
    , "      (if (>= i count)"
    , "          (reverse acc)"
    , "          (loop (+ i 1) (cons (+ start (* i step)) acc))))))"
    , ""
    , ";; Predicates"
    , "(define (proper-list? x)"
    , "  (or (null? x)"
    , "      (and (pair? x) (proper-list? (cdr x)))))"
    , "(define (circular-list? x)"
    , "  (let loop ((slow x) (fast x))"
    , "    (and (pair? fast)"
    , "         (pair? (cdr fast))"
    , "         (let ((slow2 (cdr slow))"
    , "               (fast2 (cddr fast)))"
    , "           (or (eq? slow2 fast2)"
    , "               (loop slow2 fast2))))))"
    , "(define (dotted-list? x)"
    , "  (cond ((null? x) #f)"
    , "        ((pair? x) (dotted-list? (cdr x)))"
    , "        (else #t)))"
    , "(define (not-pair? x) (not (pair? x)))"
    , "(define (null-list? x)"
    , "  (cond ((pair? x) #f)"
    , "        ((null? x) #t)"
    , "        (else (error \"null-list?: not a proper list\"))))"
    , ""
    , ";; Selectors"
    , "(define first car)"
    , "(define (second x) (cadr x))"
    , "(define (third x) (caddr x))"
    , "(define (fourth x) (cadddr x))"
    , "(define (fifth x) (car (cddddr x)))"
    , "(define (sixth x) (cadr (cddddr x)))"
    , "(define (seventh x) (caddr (cddddr x)))"
    , "(define (eighth x) (cadddr (cddddr x)))"
    , "(define (ninth x) (car (cddddr (cddddr x))))"
    , "(define (tenth x) (cadr (cddddr (cddddr x))))"
    , "(define (take-right lst k)"
    , "  (list-tail lst (- (length lst) k)))"
    , "(define (drop-right lst k)"
    , "  (take lst (- (length lst) k)))"
    , "(define (last-pair lst)"
    , "  (if (null? (cdr lst)) lst (last-pair (cdr lst))))"
    , ""
    , ";; Miscellaneous"
    , "(define (concatenate lsts) (fold-right append '() lsts))"
    , "(define (append-reverse rev-head tail)"
    , "  (fold-left (lambda (acc x) (cons x acc)) tail rev-head))"
    , ";; zip - simplified single-list version for stdlib"
    , "(define (zip lst1 lst2)"
    , "  (if (or (null? lst1) (null? lst2))"
    , "      '()"
    , "      (cons (list (car lst1) (car lst2))"
    , "            (zip (cdr lst1) (cdr lst2)))))"
    , "(define (unzip1 lst) (map car lst))"
    , "(define (unzip2 lst) (values (map car lst) (map cadr lst)))"
    , "(define (count pred lst)"
    , "  (fold-left (lambda (acc x) (if (pred x) (+ acc 1) acc)) 0 lst))"
    , ""
    , ";; Fold, unfold, and map"
    , "(define (fold kons knil lst)"
    , "  (if (null? lst)"
    , "      knil"
    , "      (fold kons (kons (car lst) knil) (cdr lst))))"
    , "(define (fold-right kons knil lst)"
    , "  (if (null? lst)"
    , "      knil"
    , "      (kons (car lst) (fold-right kons knil (cdr lst)))))"
    , "(define (unfold p f g seed . tail-gen)"
    , "  (if (p seed)"
    , "      (if (null? tail-gen) '() ((car tail-gen) seed))"
    , "      (cons (f seed) (unfold p f g (g seed)))))"
    , "(define (unfold-right p f g seed . tail)"
    , "  (let loop ((seed seed) (acc (if (null? tail) '() (car tail))))"
    , "    (if (p seed)"
    , "        acc"
    , "        (loop (g seed) (cons (f seed) acc)))))"
    , "(define (reduce f ridentity lst)"
    , "  (if (null? lst)"
    , "      ridentity"
    , "      (fold f (car lst) (cdr lst))))"
    , "(define (reduce-right f ridentity lst)"
    , "  (if (null? lst)"
    , "      ridentity"
    , "      (fold-right f (last lst) (init lst))))"
    , "(define (append-map f lst)"
    , "  (concatenate (map f lst)))"
    , "(define (filter-map f lst)"
    , "  (fold-right (lambda (x acc)"
    , "                (let ((y (f x)))"
    , "                  (if y (cons y acc) acc)))"
    , "              '() lst))"
    , ""
    , ";; Filtering and partitioning"
    , "(define (remove pred lst)"
    , "  (filter (lambda (x) (not (pred x))) lst))"
    , "(define (partition pred lst)"
    , "  (let loop ((lst lst) (yes '()) (no '()))"
    , "    (cond ((null? lst) (values (reverse yes) (reverse no)))"
    , "          ((pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no))"
    , "          (else (loop (cdr lst) yes (cons (car lst) no))))))"
    , ""
    , ";; Searching"
    , "(define (find pred lst)"
    , "  (cond ((null? lst) #f)"
    , "        ((pred (car lst)) (car lst))"
    , "        (else (find pred (cdr lst)))))"
    , "(define (find-tail pred lst)"
    , "  (cond ((null? lst) #f)"
    , "        ((pred (car lst)) lst)"
    , "        (else (find-tail pred (cdr lst)))))"
    , "(define (take-while pred lst)"
    , "  (cond ((null? lst) '())"
    , "        ((pred (car lst)) (cons (car lst) (take-while pred (cdr lst))))"
    , "        (else '())))"
    , "(define (drop-while pred lst)"
    , "  (cond ((null? lst) '())"
    , "        ((pred (car lst)) (drop-while pred (cdr lst)))"
    , "        (else lst)))"
    , "(define (span pred lst)"
    , "  (values (take-while pred lst) (drop-while pred lst)))"
    , "(define (break pred lst)"
    , "  (span (lambda (x) (not (pred x))) lst))"
    , "(define (list-index pred lst)"
    , "  (let loop ((lst lst) (i 0))"
    , "    (cond ((null? lst) #f)"
    , "          ((pred (car lst)) i)"
    , "          (else (loop (cdr lst) (+ i 1))))))"
    , ""
    , ";; Deletion"
    , "(define (delete x lst . compare)"
    , "  (let ((= (if (null? compare) equal? (car compare))))"
    , "    (remove (lambda (y) (= x y)) lst)))"
    , "(define (delete-duplicates lst . compare)"
    , "  (let ((= (if (null? compare) equal? (car compare))))"
    , "    (fold-right (lambda (x acc)"
    , "                  (if (member x acc =) acc (cons x acc)))"
    , "                '() lst)))"
    , ""
    , ";; Association lists"
    , "(define (alist-cons key datum alist)"
    , "  (cons (cons key datum) alist))"
    , "(define (alist-copy alist)"
    , "  (map (lambda (pair) (cons (car pair) (cdr pair))) alist))"
    , "(define (alist-delete key alist . compare)"
    , "  (let ((= (if (null? compare) equal? (car compare))))"
    , "    (remove (lambda (pair) (= key (car pair))) alist)))"
    , ""
    , ";; Set operations on lists"
    , "(define (lset-union = . lsts)"
    , "  (reduce (lambda (lst1 lst2)"
    , "            (fold-right (lambda (x acc)"
    , "                          (if (member x acc =) acc (cons x acc)))"
    , "                        lst1 lst2))"
    , "          '() lsts))"
    , "(define (lset-intersection = . lsts)"
    , "  (if (null? lsts)"
    , "      '()"
    , "      (reduce (lambda (lst1 lst2)"
    , "                (filter (lambda (x) (member x lst2 =)) lst1))"
    , "              (car lsts) (cdr lsts))))"
    , "(define (lset-difference = lst . lsts)"
    , "  (if (null? lsts)"
    , "      lst"
    , "      (let ((others (apply lset-union = lsts)))"
    , "        (remove (lambda (x) (member x others =)) lst))))"
    ]

-- | Create environment with primitives and stdlib
primitiveEnvWithStdlib :: IO Env
primitiveEnvWithStdlib = do
    env <- primitiveBindings
    loadStdlib env
    return env
  where
    loadStdlib env = do
        result <- runExceptT $ do
            exprs <- liftThrows $ readExprList stdlib
            mapM_ (eval env) exprs
        case result of
            Left err -> putStrLn $ "Error loading stdlib: " ++ show err
            Right _  -> return ()

-- | Run REPL
runRepl :: IO ()
runRepl = do
    putStrLn "R5RS Scheme Interpreter"
    putStrLn "Type (exit) or Ctrl-D to quit"
    putStrLn ""
    env <- primitiveEnvWithStdlib
    repl env

-- | REPL loop
repl :: Env -> IO ()
repl env = do
    putStr "scheme> "
    hFlush stdout
    eof <- isEOF
    unless eof $ do
        input <- getLine
        case input of
            "(exit)" -> return ()
            "(quit)" -> return ()
            ""       -> repl env
            _        -> do
                result <- evalString env input
                unless (null result) $ putStrLn result
                repl env

-- | Run a file
runFile :: String -> IO ()
runFile filename = do
    env <- primitiveEnvWithStdlib
    contents <- readFile filename
    result <- runExceptT $ do
        exprs <- liftThrows $ readExprList contents
        results <- mapM (eval env) exprs
        return $ last results
    case result of
        Left err  -> putStrLn $ "Error: " ++ show err
        Right val -> unless (val == Void) $ print val
